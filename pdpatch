#!/usr/bin/env python3
"""
pdpatch - Safe CLI for Pure Data patch editing

Text-based editing that preserves file structure exactly.
Does NOT use pdpy's serialization (which reorders comments).

Usage:
    pdpatch list <patch.pd>                    # List objects with indices
    pdpatch add <patch.pd> <type> [args...]    # Add object at end
    pdpatch connect <patch.pd> <src> <dst>     # Add connection
    pdpatch delete <patch.pd> <index>          # Delete by index
"""

import sys
import re
import argparse
from pathlib import Path
from dataclasses import dataclass
from typing import List, Optional, Tuple

# Try to import registry for IO validation
try:
    script_dir = Path(__file__).parent.resolve()
    if (script_dir / 'pdpy_lib').exists():
        sys.path.insert(0, str(script_dir))
    from pdpy_lib.ir.registry import get_registry
    REGISTRY = get_registry()
except:
    REGISTRY = None


@dataclass
class PdObject:
    """Represents a parsed Pd object."""
    index: int          # Object index (for connections)
    line_num: int       # Line number in file (1-based)
    obj_type: str       # Object type (osc~, dac~, etc.)
    args: List[str]     # Arguments
    x: int              # X position
    y: int              # Y position
    raw_line: str       # Original line text
    canvas_depth: int   # 0 = root, 1 = first subpatch, etc.


@dataclass
class PdCanvas:
    """Represents a canvas/subpatch."""
    name: str
    start_line: int
    end_line: int
    depth: int
    objects: List[PdObject]


def parse_pd_file(path: Path) -> Tuple[List[str], List[PdObject], List[PdCanvas]]:
    """Parse a .pd file, extracting objects and structure.

    Returns (lines, objects, canvases).
    """
    with open(path, 'r') as f:
        lines = f.readlines()

    objects = []
    canvases = []
    canvas_stack = []  # Stack of (name, start_line, depth)

    # Object index counter - resets for each canvas scope
    # But for connections, Pd uses global sequential index within each canvas
    current_depth = 0
    index_at_depth = {0: 0}  # depth -> next index

    for line_num, line in enumerate(lines, 1):
        line_stripped = line.strip()

        # Track canvas/subpatch boundaries
        if line_stripped.startswith('#N canvas'):
            if canvas_stack:
                # Entering a subpatch
                current_depth += 1
                index_at_depth[current_depth] = 0
            # Extract canvas name if present
            parts = line_stripped.split()
            name = parts[6] if len(parts) > 6 else 'root'
            canvas_stack.append((name, line_num, current_depth))

        elif line_stripped.startswith('#X restore'):
            # Exiting a subpatch
            if canvas_stack:
                name, start_line, depth = canvas_stack.pop()
                canvases.append(PdCanvas(
                    name=name,
                    start_line=start_line,
                    end_line=line_num,
                    depth=depth,
                    objects=[o for o in objects if o.canvas_depth == depth]
                ))
            if current_depth > 0:
                current_depth -= 1

        # Parse objects (things that get indices)
        # These are: obj, msg, floatatom, symbolatom, text, array, listbox
        if line_stripped.startswith('#X obj '):
            match = re.match(r'#X obj (\d+) (\d+) ([^;]+);?', line_stripped)
            if match:
                x, y = int(match.group(1)), int(match.group(2))
                rest = match.group(3).split()
                obj_type = rest[0] if rest else ''
                args = rest[1:] if len(rest) > 1 else []

                idx = index_at_depth.get(current_depth, 0)
                objects.append(PdObject(
                    index=idx,
                    line_num=line_num,
                    obj_type=obj_type,
                    args=args,
                    x=x, y=y,
                    raw_line=line,
                    canvas_depth=current_depth
                ))
                index_at_depth[current_depth] = idx + 1

        elif line_stripped.startswith('#X msg '):
            match = re.match(r'#X msg (\d+) (\d+) ([^;]*);?', line_stripped)
            if match:
                x, y = int(match.group(1)), int(match.group(2))
                content = match.group(3)

                idx = index_at_depth.get(current_depth, 0)
                objects.append(PdObject(
                    index=idx,
                    line_num=line_num,
                    obj_type='msg',
                    args=[content] if content else [],
                    x=x, y=y,
                    raw_line=line,
                    canvas_depth=current_depth
                ))
                index_at_depth[current_depth] = idx + 1

        elif line_stripped.startswith('#X text '):
            match = re.match(r'#X text (\d+) (\d+) ([^;]*);?', line_stripped)
            if match:
                x, y = int(match.group(1)), int(match.group(2))
                content = match.group(3)

                idx = index_at_depth.get(current_depth, 0)
                objects.append(PdObject(
                    index=idx,
                    line_num=line_num,
                    obj_type='text',
                    args=[content] if content else [],
                    x=x, y=y,
                    raw_line=line,
                    canvas_depth=current_depth
                ))
                index_at_depth[current_depth] = idx + 1

        elif line_stripped.startswith('#X floatatom ') or line_stripped.startswith('#X symbolatom '):
            # These also count as objects
            parts = line_stripped.split()
            if len(parts) >= 4:
                x, y = int(parts[2]), int(parts[3])
                obj_type = parts[1]

                idx = index_at_depth.get(current_depth, 0)
                objects.append(PdObject(
                    index=idx,
                    line_num=line_num,
                    obj_type=obj_type,
                    args=parts[4:],
                    x=x, y=y,
                    raw_line=line,
                    canvas_depth=current_depth
                ))
                index_at_depth[current_depth] = idx + 1

    return lines, objects, canvases


def find_insertion_point(lines: List[str], depth: int = 0) -> int:
    """Find the line number where new objects should be inserted.

    For root canvas (depth=0): before the first #X connect or end of file.
    """
    # Find the last object/msg/text line at this depth, insert after it
    # Or find the first #X connect and insert before it

    current_depth = 0
    last_object_line = 0
    first_connect_line = None

    for i, line in enumerate(lines):
        line_stripped = line.strip()

        if line_stripped.startswith('#N canvas'):
            if current_depth > 0 or last_object_line > 0:
                current_depth += 1
        elif line_stripped.startswith('#X restore'):
            if current_depth > 0:
                current_depth -= 1

        if current_depth == depth:
            if (line_stripped.startswith('#X obj ') or
                line_stripped.startswith('#X msg ') or
                line_stripped.startswith('#X text ') or
                line_stripped.startswith('#X floatatom ') or
                line_stripped.startswith('#X symbolatom ')):
                last_object_line = i
            elif line_stripped.startswith('#X connect ') and first_connect_line is None:
                first_connect_line = i

    if first_connect_line is not None:
        return first_connect_line
    return last_object_line + 1


def get_next_position(objects: List[PdObject], depth: int = 0) -> Tuple[int, int]:
    """Calculate position for new object."""
    depth_objects = [o for o in objects if o.canvas_depth == depth]

    if not depth_objects:
        return (50, 50)

    # Find max y and place below
    max_y = max(o.y for o in depth_objects)
    return (50, min(max_y + 40, 800))


def get_io_count(obj_type: str, args: List[str]) -> Tuple[int, int]:
    """Get inlet and outlet count for an object type."""
    if REGISTRY is None:
        return (1, 1)
    try:
        return REGISTRY.get_io_count(obj_type, args)
    except:
        return (1, 1)


def cmd_list(args):
    """List all objects in a patch."""
    path = Path(args.patch)
    if not path.exists():
        print(f"File not found: {path}", file=sys.stderr)
        return 1

    lines, objects, canvases = parse_pd_file(path)

    # Filter by depth (root = 0)
    target_depth = 0
    if args.subpatch:
        # Find the subpatch
        for canvas in canvases:
            if canvas.name == args.subpatch:
                target_depth = canvas.depth + 1
                break
        else:
            print(f"Subpatch '{args.subpatch}' not found", file=sys.stderr)
            available = [c.name for c in canvases if c.name != 'root']
            if available:
                print(f"Available: {', '.join(available)}", file=sys.stderr)
            return 1

    depth_objects = [o for o in objects if o.canvas_depth == target_depth]

    if not depth_objects:
        print("(empty)")
        return 0

    subpatch_info = f" [{args.subpatch}]" if args.subpatch else ""
    print(f"Objects in {path.name}{subpatch_info}:")

    for obj in depth_objects:
        args_str = ' '.join(obj.args) if obj.args else ''
        if obj.obj_type == 'text':
            # Show comment content
            print(f"  [{obj.index}] (comment) {args_str[:40]}...")
        else:
            if args.verbose:
                inlets, outlets = get_io_count(obj.obj_type, obj.args)
                io_info = f"  # {inlets}in/{outlets}out"
            else:
                io_info = ""
            print(f"  [{obj.index}] {obj.obj_type} {args_str}{io_info}")

    # Show connections at this depth
    print(f"\nConnections:")
    current_depth = 0
    for line in lines:
        line_stripped = line.strip()
        if line_stripped.startswith('#N canvas') and current_depth >= 0:
            current_depth += 1
        elif line_stripped.startswith('#X restore'):
            current_depth -= 1
        elif line_stripped.startswith('#X connect ') and current_depth == target_depth + 1:
            match = re.match(r'#X connect (\d+) (\d+) (\d+) (\d+);?', line_stripped)
            if match:
                src, src_port, dst, dst_port = match.groups()
                print(f"  [{src}]:{src_port} -> [{dst}]:{dst_port}")

    return 0


def cmd_add(args):
    """Add an object to a patch."""
    path = Path(args.patch)
    if not path.exists():
        print(f"File not found: {path}", file=sys.stderr)
        return 1

    lines, objects, canvases = parse_pd_file(path)

    # For now, only support root canvas
    depth = 0
    if args.subpatch:
        print("Subpatch add not yet supported in safe mode", file=sys.stderr)
        return 1

    # Calculate next index
    depth_objects = [o for o in objects if o.canvas_depth == depth]
    next_index = max((o.index for o in depth_objects), default=-1) + 1

    # Calculate position
    x, y = get_next_position(objects, depth)

    # Build the object line
    obj_type = args.type
    obj_args = ' '.join(args.args) if args.args else ''
    if obj_args:
        new_line = f"#X obj {x} {y} {obj_type} {obj_args};\n"
    else:
        new_line = f"#X obj {x} {y} {obj_type};\n"

    # Find insertion point (before first #X connect)
    insert_at = find_insertion_point(lines, depth)

    # Insert the line
    lines.insert(insert_at, new_line)

    # Write back
    with open(path, 'w') as f:
        f.writelines(lines)

    print(f"Added [{next_index}]: {obj_type} {obj_args} at ({x}, {y})")
    return 0


def cmd_connect(args):
    """Add a connection between two objects."""
    path = Path(args.patch)
    if not path.exists():
        print(f"File not found: {path}", file=sys.stderr)
        return 1

    lines, objects, canvases = parse_pd_file(path)

    # Parse source and destination
    try:
        src_idx = int(args.src)
        dst_idx = int(args.dst)
    except ValueError:
        print("Error: source and destination must be object indices (numbers)", file=sys.stderr)
        print("Use 'pdpatch list' to see object indices", file=sys.stderr)
        return 1

    # Find the objects
    src_obj = next((o for o in objects if o.index == src_idx and o.canvas_depth == 0), None)
    dst_obj = next((o for o in objects if o.index == dst_idx and o.canvas_depth == 0), None)

    if src_obj is None:
        print(f"Source object [{src_idx}] not found", file=sys.stderr)
        return 1
    if dst_obj is None:
        print(f"Destination object [{dst_idx}] not found", file=sys.stderr)
        return 1

    src_port = args.outlet if args.outlet is not None else 0
    dst_port = args.inlet if args.inlet is not None else 0

    # Validate connection
    _, src_outlets = get_io_count(src_obj.obj_type, src_obj.args)
    dst_inlets, _ = get_io_count(dst_obj.obj_type, dst_obj.args)

    if src_port >= src_outlets:
        print(f"Error: {src_obj.obj_type} only has {src_outlets} outlet(s)", file=sys.stderr)
        return 1
    if dst_port >= dst_inlets:
        print(f"Error: {dst_obj.obj_type} only has {dst_inlets} inlet(s)", file=sys.stderr)
        return 1

    # Build connection line
    new_line = f"#X connect {src_idx} {src_port} {dst_idx} {dst_port};\n"

    # Append to end of file (connections go at the end)
    # But before any trailing newlines
    while lines and lines[-1].strip() == '':
        lines.pop()
    lines.append(new_line)

    # Write back
    with open(path, 'w') as f:
        f.writelines(lines)

    print(f"Connected: [{src_idx}]{src_obj.obj_type}:{src_port} -> [{dst_idx}]{dst_obj.obj_type}:{dst_port}")
    return 0


def cmd_delete(args):
    """Delete an object from a patch."""
    path = Path(args.patch)
    if not path.exists():
        print(f"File not found: {path}", file=sys.stderr)
        return 1

    print("Delete not yet implemented in safe mode", file=sys.stderr)
    print("Edit the .pd file directly to delete objects", file=sys.stderr)
    return 1


def cmd_new(args):
    """Create a new empty patch."""
    path = Path(args.patch)

    if path.exists() and not args.force:
        print(f"File exists: {path} (use --force to overwrite)", file=sys.stderr)
        return 1

    content = "#N canvas 0 22 450 300 12;\n"
    with open(path, 'w') as f:
        f.write(content)

    print(f"Created: {path}")
    return 0


def add_subpatch_arg(parser):
    """Add the --subpatch argument to a parser."""
    parser.add_argument('-s', '--subpatch',
                       help='Target subpatch name (list only)')


def main():
    parser = argparse.ArgumentParser(
        description="Safe CLI for Pure Data patch editing (preserves file structure)",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
    pdpatch new synth.pd                    # Create empty patch
    pdpatch list synth.pd                   # Show objects with indices
    pdpatch list synth.pd -v                # Show with inlet/outlet counts
    pdpatch add synth.pd osc~ 440           # Add oscillator
    pdpatch connect synth.pd 0 1            # Connect by index
    pdpatch connect synth.pd 0 1 -o 0 -i 1  # Specify ports

Note: This version preserves file structure exactly.
For complex edits, use direct .pd file editing with pd2ir -i for indices.
        """
    )

    subparsers = parser.add_subparsers(dest='command', required=True)

    # new
    p_new = subparsers.add_parser('new', help='Create new patch')
    p_new.add_argument('patch', help='Output .pd file')
    p_new.add_argument('-f', '--force', action='store_true', help='Overwrite existing')

    # list
    p_list = subparsers.add_parser('list', help='List objects in patch')
    p_list.add_argument('patch', help='Patch file')
    p_list.add_argument('-v', '--verbose', action='store_true', help='Show inlet/outlet counts')
    add_subpatch_arg(p_list)

    # add
    p_add = subparsers.add_parser('add', help='Add object to patch')
    p_add.add_argument('patch', help='Patch file')
    p_add.add_argument('type', help='Object type (osc~, dac~, +, etc.)')
    p_add.add_argument('args', nargs='*', help='Object arguments')
    add_subpatch_arg(p_add)

    # connect
    p_connect = subparsers.add_parser('connect', help='Connect two objects')
    p_connect.add_argument('patch', help='Patch file')
    p_connect.add_argument('src', help='Source object index')
    p_connect.add_argument('dst', help='Destination object index')
    p_connect.add_argument('-o', '--outlet', type=int, help='Source outlet (default: 0)')
    p_connect.add_argument('-i', '--inlet', type=int, help='Destination inlet (default: 0)')

    # delete
    p_delete = subparsers.add_parser('delete', help='Delete object (not yet implemented)')
    p_delete.add_argument('patch', help='Patch file')
    p_delete.add_argument('index', help='Object index')

    args = parser.parse_args()

    commands = {
        'new': cmd_new,
        'list': cmd_list,
        'add': cmd_add,
        'connect': cmd_connect,
        'delete': cmd_delete,
    }

    return commands[args.command](args)


if __name__ == '__main__':
    sys.exit(main())
