#!/usr/bin/env python3
"""
pdpatch - CLI for programmatic Pure Data patch editing

Uses pdpy's internal object tracking to handle indices automatically.

Usage:
    pdpatch new <name.pd>                      # Create empty patch
    pdpatch add <patch.pd> <type> [args...]    # Add object, prints ID
    pdpatch connect <patch.pd> <src> <dst>     # Connect by ID or type
    pdpatch list <patch.pd>                    # List objects with IDs
    pdpatch delete <patch.pd> <id>             # Delete object by ID

Subpatch support:
    pdpatch list <patch.pd> -s envelope        # List objects in subpatch
    pdpatch add <patch.pd> osc~ 440 -s synth   # Add to subpatch
    pdpatch list <patch.pd> -s synth/filter    # Nested subpatch path
"""

import sys
import argparse
from pathlib import Path

# Add pdpy to path if running from repo
script_dir = Path(__file__).parent.resolve()
if (script_dir / 'pdpy_lib').exists():
    sys.path.insert(0, str(script_dir))

from pdpy_lib.patching.pdpy import PdPy
from pdpy_lib.patching.canvas import Canvas
from pdpy_lib.objects.obj import Obj
from pdpy_lib.objects.msg import Msg
from pdpy_lib.objects.comment import Comment
from pdpy_lib.connections.edge import Edge
from pdpy_lib.connections.iolet import Iolet
from pdpy_lib.utilities.utils import loadPdFile, parsePdFileLines

# Try to import the registry for connection validation
try:
    from pdpy_lib.ir.registry import get_registry
    REGISTRY = get_registry()
except ImportError:
    REGISTRY = None


def load_patch(path: Path) -> PdPy:
    """Load a .pd file into PdPy."""
    raw = loadPdFile(str(path))
    pd_lines = parsePdFileLines(raw)
    return PdPy(name=path.stem, pd_lines=pd_lines)


def save_patch(pdpy: PdPy, path: Path):
    """Save PdPy to .pd file."""
    with open(path, 'w') as f:
        f.write(pdpy.__pd__())


def find_canvas(pdpy: PdPy, subpatch_path: str = None):
    """Find a canvas by subpatch path (e.g., 'envelope' or 'synth/filter').

    Returns (canvas, error_message). If error_message is not None, canvas is None.
    """
    canvas = pdpy.root if hasattr(pdpy, 'root') else pdpy

    if not subpatch_path:
        return canvas, None

    # Split path into components (e.g., "synth/filter" -> ["synth", "filter"])
    parts = subpatch_path.split('/')

    for part in parts:
        # Look for a Canvas node with matching name
        found = None
        for node in getattr(canvas, 'nodes', []):
            if isinstance(node, Canvas) or hasattr(node, 'nodes'):
                node_name = getattr(node, 'name', None)
                if node_name == part:
                    found = node
                    break

        if found is None:
            # List available subpatches for better error message
            available = []
            for node in getattr(canvas, 'nodes', []):
                if isinstance(node, Canvas) or hasattr(node, 'nodes'):
                    name = getattr(node, 'name', None)
                    if name:
                        available.append(name)

            if available:
                return None, f"Subpatch '{part}' not found. Available: {', '.join(available)}"
            else:
                return None, f"Subpatch '{part}' not found. No subpatches in current canvas."

        canvas = found

    return canvas, None


def get_canvas(pdpy: PdPy, subpatch: str = None):
    """Get the target canvas (root or subpatch)."""
    canvas, error = find_canvas(pdpy, subpatch)
    if error:
        print(f"Error: {error}", file=sys.stderr)
        return None
    return canvas


def get_next_position(canvas) -> tuple:
    """Calculate a reasonable position for a new object.

    Finds the lowest object in the canvas and places the new one below it.
    Uses a grid-based layout with reasonable spacing.
    """
    nodes = getattr(canvas, 'nodes', [])

    if not nodes:
        return (50, 50)

    # Find the maximum y position among existing objects
    max_y = 50
    for node in nodes:
        if hasattr(node, 'position') and node.position:
            y = getattr(node.position, 'y', 0) or 0
            if y > max_y:
                max_y = y

    # Place new object 40 pixels below the lowest one
    # But cap at reasonable values to avoid runaway positions
    new_y = min(max_y + 40, 500)

    return (50, new_y)


def get_object_io_count(obj) -> tuple:
    """Get inlet and outlet count for an object using the registry.

    Returns (inlet_count, outlet_count). Returns (1, 1) as default.
    """
    if REGISTRY is None:
        return (1, 1)

    obj_type = getattr(obj, 'className', None)
    if not obj_type:
        return (1, 1)

    # Get args - handle pdpy's space-joined format
    args = []
    if hasattr(obj, 'args') and obj.args:
        for arg in obj.args:
            args.extend(str(arg).split())

    try:
        return REGISTRY.get_io_count(obj_type, args)
    except:
        return (1, 1)


def list_objects(canvas) -> list:
    """List all objects with their IDs."""
    objects = []

    for i, node in enumerate(getattr(canvas, 'nodes', [])):
        # Check if it's a subpatch (Canvas)
        is_subpatch = isinstance(node, Canvas) or hasattr(node, 'nodes')

        if is_subpatch:
            obj_type = f"pd {getattr(node, 'name', '?')}"
            args_str = ''
            child_count = len(getattr(node, 'nodes', []))
        else:
            obj_type = getattr(node, 'className', getattr(node, '__pdpy__', '?'))
            args = getattr(node, 'args', [])
            args_str = ' '.join(str(a) for a in args) if args else ''
            child_count = 0

        obj_id = getattr(node, 'id', i)

        # Get IO counts for validation info
        inlet_count, outlet_count = get_object_io_count(node)

        objects.append({
            'id': obj_id,
            'index': i,
            'type': obj_type,
            'args': args_str,
            'is_subpatch': is_subpatch,
            'child_count': child_count,
            'inlets': inlet_count,
            'outlets': outlet_count,
        })

    return objects


def find_object(canvas, identifier: str):
    """Find object by ID, index, or type+args."""
    nodes = getattr(canvas, 'nodes', [])

    # Try as numeric ID/index
    try:
        idx = int(identifier)
        # First try as ID
        for node in nodes:
            if getattr(node, 'id', None) == idx:
                return node
        # Then as index
        if 0 <= idx < len(nodes):
            return nodes[idx]
    except ValueError:
        pass

    # Try as type (e.g., "osc~" or "osc~ 440")
    parts = identifier.split()
    obj_type = parts[0]
    obj_args = ' '.join(parts[1:]) if len(parts) > 1 else None

    for node in nodes:
        node_type = getattr(node, 'className', '')
        # Also check subpatch names
        if not node_type and hasattr(node, 'name'):
            node_type = f"pd {node.name}"

        if node_type == obj_type:
            if obj_args is None:
                return node
            node_args = ' '.join(str(a) for a in getattr(node, 'args', []))
            if node_args == obj_args:
                return node

    return None


def cmd_new(args):
    """Create a new empty patch."""
    path = Path(args.patch)

    if path.exists() and not args.force:
        print(f"File exists: {path} (use --force to overwrite)", file=sys.stderr)
        return 1

    pdpy = PdPy(name=path.stem, root=True)
    save_patch(pdpy, path)
    print(f"Created: {path}")
    return 0


def cmd_add(args):
    """Add an object to a patch."""
    path = Path(args.patch)

    if not path.exists():
        print(f"File not found: {path}", file=sys.stderr)
        return 1

    pdpy = load_patch(path)
    canvas = get_canvas(pdpy, getattr(args, 'subpatch', None))
    if canvas is None:
        return 1

    # Create the object
    obj_type = args.type
    obj_args = args.args if args.args else []

    # Calculate position - find a reasonable spot
    x, y = get_next_position(canvas)

    # Handle special types
    if obj_type == 'msg':
        obj = Msg(x=x, y=y)
        if obj_args:
            obj.addargs(*obj_args)
    elif obj_type == 'text' or obj_type == 'comment':
        obj = Comment(' '.join(obj_args), x=x, y=y)
    else:
        obj = Obj(className=obj_type, x=x, y=y)
        if obj_args:
            obj.addargs(*obj_args)

    # Add to canvas - this assigns the ID
    canvas.grow()
    obj.id = canvas.add(obj)

    save_patch(pdpy, path)

    # Print the assigned ID
    subpatch_info = f" (in {args.subpatch})" if getattr(args, 'subpatch', None) else ""
    print(f"Added [{obj.id}]: {obj_type} {' '.join(str(a) for a in obj_args)}{subpatch_info}")
    return 0


def cmd_connect(args):
    """Connect two objects."""
    path = Path(args.patch)

    if not path.exists():
        print(f"File not found: {path}", file=sys.stderr)
        return 1

    pdpy = load_patch(path)
    canvas = get_canvas(pdpy, getattr(args, 'subpatch', None))
    if canvas is None:
        return 1

    # Find source and destination
    src = find_object(canvas, args.src)
    dst = find_object(canvas, args.dst)

    if src is None:
        print(f"Source not found: {args.src}", file=sys.stderr)
        return 1
    if dst is None:
        print(f"Destination not found: {args.dst}", file=sys.stderr)
        return 1

    # Get port numbers
    src_port = args.outlet if args.outlet is not None else 0
    dst_port = args.inlet if args.inlet is not None else 0

    # Validate connection using registry
    src_type = getattr(src, 'className', getattr(src, 'name', '?'))
    dst_type = getattr(dst, 'className', getattr(dst, 'name', '?'))

    _, src_outlet_count = get_object_io_count(src)
    dst_inlet_count, _ = get_object_io_count(dst)

    # Check outlet validity
    if src_port >= src_outlet_count:
        print(f"Error: {src_type} only has {src_outlet_count} outlet(s), cannot use outlet {src_port}", file=sys.stderr)
        return 1

    # Check inlet validity
    if dst_port >= dst_inlet_count:
        print(f"Error: {dst_type} only has {dst_inlet_count} inlet(s), cannot use inlet {dst_port}", file=sys.stderr)
        return 1

    # Create edge
    edge = Edge(pd_lines=[src.id, src_port, dst.id, dst_port])
    canvas.edge(edge)

    save_patch(pdpy, path)

    print(f"Connected: [{src.id}]{src_type}:{src_port} -> [{dst.id}]{dst_type}:{dst_port}")
    return 0


def cmd_list(args):
    """List all objects in a patch."""
    path = Path(args.patch)

    if not path.exists():
        print(f"File not found: {path}", file=sys.stderr)
        return 1

    pdpy = load_patch(path)
    canvas = get_canvas(pdpy, getattr(args, 'subpatch', None))
    if canvas is None:
        return 1

    objects = list_objects(canvas)

    subpatch_info = f" [{args.subpatch}]" if getattr(args, 'subpatch', None) else ""

    if not objects:
        print(f"(empty canvas{subpatch_info})")
        return 0

    print(f"Objects in {path.name}{subpatch_info}:")
    for obj in objects:
        args_str = f" {obj['args']}" if obj['args'] else ""
        if obj['is_subpatch']:
            print(f"  [{obj['id']}] {obj['type']} ({obj['child_count']} objects)")
        else:
            io_info = f"  # {obj['inlets']}in/{obj['outlets']}out" if args.verbose else ""
            print(f"  [{obj['id']}] {obj['type']}{args_str}{io_info}")

    # Also show connections
    edges = getattr(canvas, 'edges', [])
    if edges:
        print(f"\nConnections:")
        for edge in edges:
            src_id = edge.source.id if hasattr(edge.source, 'id') else '?'
            src_port = edge.source.port if hasattr(edge.source, 'port') else 0
            dst_id = edge.sink.id if hasattr(edge.sink, 'id') else '?'
            dst_port = edge.sink.port if hasattr(edge.sink, 'port') else 0
            print(f"  [{src_id}]:{src_port} -> [{dst_id}]:{dst_port}")

    return 0


def cmd_delete(args):
    """Delete an object from a patch."""
    path = Path(args.patch)

    if not path.exists():
        print(f"File not found: {path}", file=sys.stderr)
        return 1

    pdpy = load_patch(path)
    canvas = get_canvas(pdpy, getattr(args, 'subpatch', None))
    if canvas is None:
        return 1

    obj = find_object(canvas, args.id)
    if obj is None:
        print(f"Object not found: {args.id}", file=sys.stderr)
        return 1

    # Remove from nodes
    nodes = getattr(canvas, 'nodes', [])
    obj_id = obj.id
    obj_type = getattr(obj, 'className', getattr(obj, 'name', '?'))

    if obj in nodes:
        nodes.remove(obj)

    # Remove connected edges
    edges = getattr(canvas, 'edges', [])
    edges_to_remove = []
    for edge in edges:
        src_id = edge.source.id if hasattr(edge.source, 'id') else None
        dst_id = edge.sink.id if hasattr(edge.sink, 'id') else None
        if src_id == obj_id or dst_id == obj_id:
            edges_to_remove.append(edge)

    for edge in edges_to_remove:
        edges.remove(edge)

    save_patch(pdpy, path)

    print(f"Deleted [{obj_id}]: {obj_type}")
    if edges_to_remove:
        print(f"  (removed {len(edges_to_remove)} connection(s))")

    return 0


def add_subpatch_arg(parser):
    """Add the --subpatch argument to a parser."""
    parser.add_argument('-s', '--subpatch',
                       help='Target subpatch (e.g., "envelope" or "synth/filter")')


def main():
    parser = argparse.ArgumentParser(
        description="CLI for programmatic Pure Data patch editing",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
    pdpatch new synth.pd                    # Create empty patch
    pdpatch add synth.pd osc~ 440           # Add oscillator
    pdpatch add synth.pd dac~               # Add audio output
    pdpatch list synth.pd                   # Show objects with IDs
    pdpatch connect synth.pd 0 1            # Connect by ID
    pdpatch connect synth.pd "osc~" "dac~"  # Connect by type
    pdpatch delete synth.pd 0               # Delete object

Subpatch examples:
    pdpatch list synth.pd -s envelope       # List subpatch contents
    pdpatch add synth.pd line~ -s envelope  # Add to subpatch
    pdpatch list synth.pd -s voice/filter   # Nested subpatch
        """
    )

    subparsers = parser.add_subparsers(dest='command', required=True)

    # new
    p_new = subparsers.add_parser('new', help='Create new patch')
    p_new.add_argument('patch', help='Output .pd file')
    p_new.add_argument('-f', '--force', action='store_true', help='Overwrite existing')

    # add
    p_add = subparsers.add_parser('add', help='Add object to patch')
    p_add.add_argument('patch', help='Patch file')
    p_add.add_argument('type', help='Object type (osc~, dac~, +, etc.)')
    p_add.add_argument('args', nargs='*', help='Object arguments')
    add_subpatch_arg(p_add)

    # connect
    p_connect = subparsers.add_parser('connect', help='Connect two objects')
    p_connect.add_argument('patch', help='Patch file')
    p_connect.add_argument('src', help='Source object (ID, index, or "type args")')
    p_connect.add_argument('dst', help='Destination object')
    p_connect.add_argument('-o', '--outlet', type=int, help='Source outlet (default: 0)')
    p_connect.add_argument('-i', '--inlet', type=int, help='Destination inlet (default: 0)')
    add_subpatch_arg(p_connect)

    # list
    p_list = subparsers.add_parser('list', help='List objects in patch')
    p_list.add_argument('patch', help='Patch file')
    p_list.add_argument('-v', '--verbose', action='store_true', help='Show inlet/outlet counts')
    add_subpatch_arg(p_list)

    # delete
    p_delete = subparsers.add_parser('delete', help='Delete object from patch')
    p_delete.add_argument('patch', help='Patch file')
    p_delete.add_argument('id', help='Object ID or type')
    add_subpatch_arg(p_delete)

    args = parser.parse_args()

    commands = {
        'new': cmd_new,
        'add': cmd_add,
        'connect': cmd_connect,
        'list': cmd_list,
        'delete': cmd_delete,
    }

    return commands[args.command](args)


if __name__ == '__main__':
    sys.exit(main())
